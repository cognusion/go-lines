

# lines
`import "github.com/cognusion/go-lines"`

* [Overview](#pkg-overview)
* [Index](#pkg-index)
* [Examples](#pkg-examples)

## <a name="pkg-overview">Overview</a>
Package lines is a multipurpose ASCII line truncator, that ensures outputted lines do not exceed a specified length ever.
I was unimpressed with the packages I found for quality, speed, or both.

There is a major blindspot here with regards to multibyte characters. That's not a thing I am working toward due to its inherent
complexity and the purpose of this mod. PRs are welcome, but better packages probably exist
elsewhere.




## <a name="pkg-index">Index</a>
* [func LinifyStream(stream &lt;-chan string, out io.StringWriter, max int) error](#LinifyStream)
* [func LinifyStreamSeparator(stream &lt;-chan string, out io.StringWriter, max int, separator string) error](#LinifyStreamSeparator)
* [func LinifyString(s string, max int) string](#LinifyString)
* [func RawLinifyString(s string, max int) string](#RawLinifyString)

#### <a name="pkg-examples">Examples</a>
* [LinifyStream](#example-linifystream)

#### <a name="pkg-files">Package files</a>
[lines.go](https://github.com/cognusion/go-lines/tree/master/lines.go)





## <a name="LinifyStream">func</a> [LinifyStream](https://github.com/cognusion/go-lines/tree/master/lines.go?s=2286:2361#L83)
``` go
func LinifyStream(stream <-chan string, out io.StringWriter, max int) error
```
LinifyStream consumes a string chan and pushes linified results to the specified io.StringWriter.
An error is returned IFF the io.StringWriter returns an error.
This is only meaningfully efficient for arbitrarily massive sets of strings. Unless you are
linifying 'The Tommyknockers' or 'War and Peace', I doubt this is what you're looking for.


##### Example LinifyStream:
``` go
// You are going to have a scanner with an unknown,
// never-ending buffer of words that need to be
// assembled with spaces between, and newlines on or
// before some max line length.
fields := strings.FieldsSeq("This line is not that long. But imagine it is much longer.")

// create a channel for those words to pipe over
wordChan := make(chan string)

// create a possibly never-ending stream to send words to the wordChan
go func() {
    defer close(wordChan) // super important, if we ever want to end
    for word := range fields {
        wordChan <- word
    }
}()

// Linify the stream from wordChan, write to os.StdOut, each line max 20 characters, separate by space.
err := LinifyStream(wordChan, os.Stdout, 20)
if err != nil {
    // for real?!
    panic(err)
}
// Output: This line is not
//that long. But
//imagine it is much
//longer.
```

Output:

```
This line is not
that long. But
imagine it is much
longer.
```


## <a name="LinifyStreamSeparator">func</a> [LinifyStreamSeparator](https://github.com/cognusion/go-lines/tree/master/lines.go?s=2845:2947#L92)
``` go
func LinifyStreamSeparator(stream <-chan string, out io.StringWriter, max int, separator string) error
```
LinifyStreamSeparator consumes a string chan and pushes linified results to the specified io.StringWriter.
The separator may specify what is used to separate words.
An error is returned IFF the io.StringWriter returns an error.
This is only meaningfully efficient for arbitrarily massive sets of strings. Unless you are
linifying 'The Tommyknockers' or 'War and Peace', I doubt this is what you're looking for.



## <a name="LinifyString">func</a> [LinifyString](https://github.com/cognusion/go-lines/tree/master/lines.go?s=1070:1113#L40)
``` go
func LinifyString(s string, max int) string
```
LinifyString returns a string that has newlines inserted between word boundaries, at most every max characters.



## <a name="RawLinifyString">func</a> [RawLinifyString](https://github.com/cognusion/go-lines/tree/master/lines.go?s=607:653#L15)
``` go
func RawLinifyString(s string, max int) string
```
RawLinifyString returns a string that has newlines inserted every max characters, irrespective of word boundaries.








- - -
Generated by [godoc2md](http://github.com/cognusion/godoc2md)
